# Итераторы в Ruby

В Ruby практически не используются циклы, практически вся современная экосистема языка и приложения выстроены при помощи итераторов блоков.

## 1. Циклы Ruby

В Ruby как и в любом языке программирования имеются операторы цикла, цель которых, выполнение повторяющихся участков кода.

Например, для перебора элементов массива `[1, 2, 3, 4, 5]` можно воспользоваться циклом `for`:

    for x in [1, 2, 3, 4, 5] do
      puts x
    end
    1
    2
    3
    4
    5

Цикл пробегает значения от начала массива до последнего элемента, помещая на каждой итерации текущее значение из массива в переменную `x`. Когда значения в цикле заканчиваются, цикл завершает работу.

Еще один оператор для выполнения циклов — это `while`. Например, следующий код выводит значения от 1 до 5:

    i = 1
    while i <= 5 do
      puts i
      i += 1
    end
    1
    2
    3
    4
    5

Цикл начинается с ключевого слова `while`, после которого размещено условие. Выражение с условием возвращает либо `true` (истина), либо `false` (ложь). Пока условие возвращает `true`, цикл выполняет выражения между ключевыми словами `do` и `end`. Как только условие возвращает `false`, а это происходит когда переменная i получает значение 6, он прекращает работу.

Кроме оператора `while` существует оператор `until`, который противоположен `while`, так как выполняет блок до тех пор, пока условие ложно:

    i = 1
    until i > 5 do
      puts i
      i += 1
    end
    1
    2
    3
    4
    5

## 2. Почему Ruby-исты не используют циклы?

Перечисленные выше операторы трудно обнаружить в Ruby-коде, по крайней мере в коде конечных приложений. Вместо них, рубисты часто прибегают к итераторам, специальным методам, которые позволяют обходить коллекции.

Рассмотрим типичный итератор `each`:

    [1, 2, 3, 4, 5].each do |i|
      puts i
    end
    1
    2
    3
    4
    5

Метод `each` является именно методом объекта `[1, 2, 3, 4, 5]`, а не специальной конструкцией языка, чуть позже мы попробуем писать свои собственные методы-итераторы.

Конструкция между `do` и `end` называется блоком, и в отличие от одноименных конструкций в циклах имеет собственную область видимости, не может быть сокращена за счет удаление `do` (как в случае циклов), однако, может быть преобразована в краткую форму за счет использования фигурных скобок:

    [1, 2, 3, 4, 5].each { |i| puts i }
    1
    2
    3
    4
    5

К фигурным скобках обычно прибегают, когда блок состоит из одного выражения, в случае нескольких выражений используют полную форму блока, с использованием ключевых слов `do` и `end`.

Итератор `each` применим, не только для массивов, но и для хэшей:

    {a: 'b', c: 'd'}.each { |key, value| puts "#{key}: #{value}" }
    a: b
    c: d

Здесь блок принимает вместо одного, два параметра, `key` под ключ (:a, :c), `value` — под значения ('b', 'd').

Итераторы необязательно обслуживают коллекции, например, итератор `times` применяется к числам позволяет выполнить цикл указанное количество раз:

    5.times { |i| puts i }
    0
    1
    2
    3
    4

Причем для вещественного числа метод `times` уже не сработает:

    (5.0).times { |i| puts i }
    NoMethodError: undefined method `times' for 5.0:Float

Для итерирования от одного числа к другому можно воспользоваться методом `upto`:

    5.upto(10) { |i| puts i }
    5
    6
    7
    8
    9
    10

Метод `downto` позволяет наоборот пробегать числа с шагом минус один:

    10.downto(5) { |i| puts i }
    10
    9
    8
    7
    6
    5

Главное знать, какой итератор можно применять с текущим объектом.
